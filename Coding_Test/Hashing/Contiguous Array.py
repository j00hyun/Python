# https://leetcode.com/explore/interview/card/leetcodes-interview-crash-course-data-structures-and-algorithms/705/hashing/4845/

##### 해설

# 예시: 1, 0, 1, 1, 0

#   - 0의 개수와 1의 개수를 배열로 나타내보기 (ex. [2, 3]: 0은 2개, 1은 3개)
#     - 인덱스 -1:  [0, 0] (아무것도 없는 상태 표시)
#     - 인덱스 0:   [0, 1]
#     - 인덱스 1:   [1, 1]
#     - 인덱스 2:   [1, 2]
#     - 인덱스 3:   [1, 3]
#     - 인덱스 4:   [2, 3]

#   - 답 찾아보기
#     - 1, 0:       (인덱스 1 [1, 1] - 인덱스 -1 [0, 0]) -> 1 - 1 = 0 - 0 = 0
#     - 0, 1:       (인덱스 2 [1, 2] - 인덱스 0  [0, 1]) -> 2 - 1 = 1 - 0 = 1
#     - 0, 1, 1, 0: (인덱스 4 [2, 3] - 인덱스 0  [0, 1]) -> 3 - 2 = 1 - 0 = 1
#     - 1, 0:       (인덱스 4 [2, 3] - 인덱스 2  [1, 2]) -> 3 - 2 = 2 - 1 = 1

#   - 답을 보면 두 인덱스를 비교했을 때 모두 (1의 개수 - 0의 개수)가 동일!
#     그렇다면 개수 차로 접근하는 것은 어떨까? (코딩 시, 0에는 -1, 1에는 1 값을 부여해서 덧셈)
#     - 인덱스 -1:  [0, 0] -> 0
#     - 인덱스 0:   [0, 1] -> 1
#     - 인덱스 1:   [1, 1] -> 0   -> 인덱스 -1과 동일
#     - 인덱스 2:   [1, 2] -> 1   -> 인덱스  0과 동일
#     - 인덱스 3:   [1, 3] -> 2
#     - 인덱스 4:   [2, 3] -> 1   -> 인덱스  0, 2와 동일

#   - 그런데 인덱스 4과 동일한 값을 가지는 인덱스는 총 2개가 존재
#     하지만, 제일 긴 길이를 찾는 것이 정답이므로 답은 인덱스 4 - 인덱스 0 이다.
#     그러면 map을 통해 key는 "1의 개수 - 0의 개수", value는 "가장 처음 발견된 인덱스 값"으로 저장하면 되겠다.
#     - 인덱스 -1:  [0, 0] -> curr = 0   map = {0: -1}              ans = 0
#     - 인덱스 0:   [0, 1] -> curr = 1   map = {0: -1, 1: 0}        ans = 0
#     - 인덱스 1:   [1, 1] -> curr = 0   map = {0: -1, 1: 0}        ans = 1 - (-1) = 2
#     - 인덱스 2:   [1, 2] -> curr = 1   map = {0: -1, 1: 0}        ans = 2 - 0 = 2
#     - 인덱스 3:   [1, 3] -> curr = 2   map = {0: -1, 1: 0, 2: 3}  ans = 2
#     - 인덱스 4:   [2, 3] -> curr = 1   map = {0: -1, 1: 0, 2: 3}  ans = 4 - 0 = 4

from collections import defaultdict

class Solution:
    def findMaxLength(self, nums: List[int]) -> int:
        counts = defaultdict(int)
        counts[0] = -1
        ans = curr = 0
        
        for i in range(len(nums)):
            if nums[i] == 0: # 현재 값이 0인 경우 -1 더하기
                curr -= 1
            else: # 현재 값이 1인 경우 1 더하기
                curr += 1
            
            if curr in counts: # 이전에 "1의 개수 - 0의 개수"가 같은 인덱스가 존재한다면
                ans = max(ans, i - counts[curr]) # 최대 길이 변경
            else: # # 현재 "1의 개수 - 0의 개수" 가 최초 발견이라면
                counts[curr] = i # map에 추가
                
        return ans